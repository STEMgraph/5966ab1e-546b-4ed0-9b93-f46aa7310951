\learningobjective{At the end of this challenge, the scholar will be able to use `std::for_each` to apply a function to elements of a range in C++.}
\begin{challenge}
    \chatitle{Using `std::for_each` to process container elements}
    \begin{chadescription}
    In C++, the `std::for_each` algorithm is a versatile tool for applying a function or callable object to each element of a range (e.g., a container like `std::vector`, `std::list`, etc.).
    Unlike traditional loops, `std::for_each` works seamlessly with iterators, providing a clean and functional approach to traversing elements.
    This algorithm is part of the `<algorithm>` header and offers a concise and expressive way to implement element-wise operations.

    `std::for_each` is particularly useful when:
    \begin{itemize}
        \item You want to separate the logic of iteration from the container.
        \item You are using standard library containers with algorithms for better code readability.
        \item You aim to apply stateless or statically captured operations on elements.
    \end{itemize}

    In this challenge, we will:
    \begin{enumerate}
        \item Understand the syntax and signature of `std::for_each`.
        \item Use `std::for_each` with free functions, lambdas, and functors.
        \item Explore the implications of modifying container elements using `std::for_each`.
    \end{enumerate}
    \end{chadescription}

    \begin{task}
    Write a C++ program that uses `std::for_each` to print the elements of a `std::vector<int>`.
    \begin{enumerate}
        \item Create a `std::vector<int>` with values `{1, 2, 3, 4, 5}`.
        \item Use `std::for_each` with a lambda function to print each element.
        \item Modify the program to increment each element by 1 using `std::for_each`.
    \end{enumerate}
    \begin{questions}
        \item What is the difference between using `std::for_each` and a traditional `for` loop for this task?
        \item Can `std::for_each` return values? Why or why not?
    \end{questions}
    \end{task}

    \begin{advice}
        Remember, `std::for_each` is not ideal for operations that require breaking out of the loop early. Consider `std::find` or other algorithms for such use cases.
    \end{advice}

    \begin{task}
    Demonstrate the use of `std::for_each` with a functor (function object).
    \begin{enumerate}
        \item Define a functor class that multiplies each element by 2 and prints the result.
        \item Use `std::for_each` with this functor on a `std::list<int>`.
    \end{enumerate}
    \begin{questions}
        \item How does using a functor differ from using a lambda in this context?
        \item What are the benefits of using functors with state (e.g., internal counters)?
    \end{questions}
    \end{task}

    \begin{task}
    Use `std::for_each` to count occurrences of a specific value in a `std::vector<int>`.
    \begin{enumerate}
        \item Define a lambda that captures an external counter by reference.
        \item Iterate through the vector and increment the counter for each match.
        \item Print the total count of the value.
    \end{enumerate}
    \begin{questions}
        \item Why do we need to capture the counter by reference in the lambda?
        \item Could this task be performed using `std::count`? If so, which approach is better and why?
    \end{questions}
    \end{task}

    \begin{advice}
        Use lambdas for lightweight and inline functionality, and functors for reusable, encapsulated logic.
    \end{advice}
\end{challenge}
